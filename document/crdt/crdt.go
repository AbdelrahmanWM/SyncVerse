package crdt

import (
	action "github.com/AbdelrahmanWM/SyncVerse/document/crdt/action"
	"github.com/AbdelrahmanWM/SyncVerse/document/error_formatter.go"
	"github.com/AbdelrahmanWM/SyncVerse/document/global"

	d "github.com/AbdelrahmanWM/SyncVerse/document/crdt/data_structure"
	event "github.com/AbdelrahmanWM/SyncVerse/document/crdt/event"
	"github.com/AbdelrahmanWM/SyncVerse/document/crdt/event_priority_queue.go"
	"github.com/AbdelrahmanWM/SyncVerse/document/crdt/rope/block"
	"github.com/AbdelrahmanWM/SyncVerse/document/crdt/rope/value"
	s "github.com/AbdelrahmanWM/SyncVerse/document/crdt/sequence_number"
	v "github.com/AbdelrahmanWM/SyncVerse/document/crdt/vector_clock"
)

type CRDT struct {
	replicaID           global.ReplicaID
	currentVectorClock  v.VectorClock
	dataStructure       d.CRDTDataStructure
	eventQueue          event_priority_queue.EventPriorityQueue
	processedEvents     []*event.Event
	localSequenceNumber s.SeqNum
	observedSequenceNumberMap   s.SeqNumMap
}

func NewCRDT(dataStructure d.CRDTDataStructure, replicaID global.ReplicaID, vectorClock v.VectorClock) *CRDT {
	crdtVectorClock := vectorClock
	if crdtVectorClock == nil {
		crdtVectorClock = v.NewVectorClock(replicaID)
	}
	return &CRDT{
		replicaID,
		crdtVectorClock,
		dataStructure,
		*event_priority_queue.NewEventPriorityQueue(nil), //temp
		make([]*event.Event, 10),                         //for now
		0,
		s.NewSeqNumMap(),
	}
}

// Prepare is responsible for receiving an action from the client, and converting that action
// into an event that gets pushed to the event priority queue to be applied, and also published

func (crdt *CRDT) Prepare(a *action.Action) (*event.Event, error) {
	newVectorClock := crdt.currentVectorClock.NewVectorClock(crdt.replicaID)
	var e event.Event

	e.OriginID = crdt.replicaID
	e.VectorClock = newVectorClock
	e.LocalSequenceNumber=crdt.localSequenceNumber+1 /// duplicated in the apply as well
	e.OriginSequenceNumber=crdt.localSequenceNumber+1 ///
	
	switch a.Kind {
	case action.Insert:
		actionMetadata, ok := a.Metadata.(*action.InsertionMetadata)
		if !ok {
			return nil, error_formatter.NewError("Invalid insertion metadata")
		}
		e.Kind = event.Insert
		insertionClockOffset, err := crdt.dataStructure.FindInsertionBlockOffset(actionMetadata.Index)
		if err != nil {
			return nil, err
		}
		contentBlock := block.NewBlock(v.NewClockOffset(newVectorClock, 0), actionMetadata.Content, value.ByteBuffer, false)
		e.Metadata = event.NewInsertionEventMetadata(contentBlock, insertionClockOffset, actionMetadata.Index)
	case action.Delete:
		actionMetadata, ok := a.Metadata.(*action.DeletionMetadata)
		if !ok {
			return nil, error_formatter.NewError("Invalid deletion metadata") // todo:Make it an error
		}
		e.Kind = event.Delete
		deletionMetadata, err := crdt.dataStructure.FindBlocks(actionMetadata.Index, actionMetadata.Length)
		if err != nil {
			return nil, err
		}
		e.Metadata = event.NewDeletionEventMetadata(deletionMetadata, actionMetadata.Index)
	default:
		return nil, error_formatter.NewError("Action type not found")
	}
	crdt.eventQueue.Push(&e) // temp
	return &e, nil
}
func (crdt *CRDT) Apply(e *event.Event) error {
	if !crdt.currentVectorClock.IsValidSuccessor(e.VectorClock) {
		return error_formatter.NewError("Missing event(s)") // temp
	}

	// applying the event


	switch e.Kind {
	case event.Insert:
		insertionMetadata, ok := e.Metadata.(*event.InsertionEventMetadata)
		if !ok {
			return error_formatter.NewError("Invalid insertion metadata")
		}
		err := crdt.dataStructure.Insert(insertionMetadata.ContentBlock, insertionMetadata.ToBeInsertedAfter, insertionMetadata.StartIndex)
		if err != nil {
			return error_formatter.NewError("Failed to apply insertion event")
		}
	case event.Delete:
		deletionMetadata, ok := e.Metadata.(*event.DeletionEventMetadata)
		if !ok {
			return error_formatter.NewError("Invalid deletion metadata")
		}
		err := crdt.dataStructure.Delete(deletionMetadata.DeletionMetadata, deletionMetadata.StartIndex)
		if err != nil {
			return error_formatter.NewError("Failed to apply deletion event")
		}
	default:
		return error_formatter.NewError("Event type not found")
	}

	// updates after event application

	crdt.currentVectorClock = crdt.currentVectorClock.Merge(e.VectorClock) // merging the latest vector clock

	// update the observed sequence number of the event origin
	if e.OriginID!=crdt.replicaID{
		crdt.observedSequenceNumberMap.Update(e.OriginID,e.OriginSequenceNumber)
	}
	// incrementing the local sequence number, and assigning the new increment to the event
	e.LocalSequenceNumber=crdt.IncrementLocalSequenceNumber()

	// Note for self: the update of observed sequence number with the local sequence number of the
	// event (in case the event wasn't generated by self) will happen within the query function (or push)
	// where the maximum sequence number will be updated from there, as the event doesn't track the
	// sender of that event

	//
	crdt.processedEvents=append(crdt.processedEvents,e)

	return nil
}

func (crdt *CRDT) Query(remoteReplicaID string) []event.Event { // temp
	// webRTC interaction
	// todo: implementation
	return []event.Event{}
}
func (crdt *CRDT) DataStructure() d.CRDTDataStructure {
	return crdt.dataStructure
}
func (crdt *CRDT) Publish() { // publishing events

}
func (crdt *CRDT) Pull(replicaID global.ReplicaID, currentVectorClock v.VectorClock) { // pulling to confirm status

}


func (crdt *CRDT) IncrementLocalSequenceNumber()s.SeqNum{
	crdt.localSequenceNumber.Increment()
	return crdt.localSequenceNumber
}
// we need http ping mechanism to check for connection in case webrtc datachannel kept failing


/////////////////// SETTERS / GETTERS //////////
func(crdt * CRDT) LocalSequenceNumber()s.SeqNum{
	return crdt.localSequenceNumber
}
func(crdt * CRDT) ObservedSequenceNumberMap()s.SeqNumMap{
	return crdt.observedSequenceNumberMap
}